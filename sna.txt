install.packages("igraph")
install.packages("e1071")

# P1 Write a program to compute the following for a given a network:
#(i) number of edges
library(igraph)
# Create the graph with specified edges
g <- graph.formula(1-2, 1-3, 2-3, 2-4, 3-5, 4-5, 4-6, 4-7, 5-6, 6-7)
#Name of Edges and nodes
V(g)
E(g)
#Plotting the graph
plot(g)

#Directed graph
library(igraph)
dg <- graph.formula(1-+2, 1-+3, 2++3)
plot(g)

#Graph with names
library(igraph)
dg1 <- graph.formula(Sam-+Mary, Sam-+Tom, Mary++Tom)
plot(dg1)

#(ii) number of nodes
library(igraph)
# Creating the first graph with names
dg1 <- graph.formula(Sam-+Mary, Sam-+Tom, Mary++Tom)
plot(dg1)
# Creating the second graph with numbers
g <- graph.formula(1-2, 1-3, 2-3, 2-4, 3-5, 4-5, 4-6, 4-7, 5-6, 6-7)
# Display vertices of the graph
V(g)
# Display edges of the graph
E(g)
# Count the number of vertices
vcount(g)
# Count the number of edges
ecount(g)

#(iii) degree of node
#(iv)node with lowest degree
degree(dg1, mode="in")
# Out-degree for directed graph 'dg1'
degree(dg1, mode="out")
# Node with the lowest degree in 'dg1'
V(dg1)$name[degree(dg1) == min(degree(dg1))]
# Node with the highest degree in 'dg1'
V(dg1)$name[degree(dg1) == max(degree(dg1))]

#(v) the adjacency list
neighbors(g,5)
neighbors(g,2)
get.adjlist(dg)
get.adjacency(g)

#(vi) matrix of the graph.
get.adjacency(g)







#P2 Perform following tasks:
#(i) View data collection forms and/or import one-mode/two-mode datasets;
getwd()
setwd("C:/Users/Saail Chavan/Downloads/SNA/CSV") 
nodes <- read.csv("Dataset1-Media-Example-NODES.csv", header=T, , as.is=T)
head(nodes)
links <- read.csv("Dataset1-Media-Example-EDGES.csv", header=T, , as.is=T)
head(links)

#(ii) Basic Networks matrices transformations
net <- graph.data.frame(d=links, vertices=nodes, directed=T)
m=as.matrix(net)
get.adjacency(m)
plot(net)






#P3 Compute the following node level measures:

#(i) Density; 
library(igraph)
g <- graph.formula(1-2, 1-3, 2-3, 2-4, 3-5, 4-5, 4-6, 4-7, 5-6, 6-7)
plot(g)
vcount(g)
ecount(g)
# Calculate the density of the graph
ecount(g) / (vcount(g) * (vcount(g) - 1))

#(ii) Degree; 
nodes <- read.csv("Dataset1-Media-Example-NODES.csv", header=T, , as.is=T)
head(nodes)
links <- read.csv("Dataset1-Media-Example-EDGES.csv", header=T, , as.is=T)
head(links)
net <- graph.data.frame(d=links, vertices=nodes, directed=T)
m = as.matrix(net)
get.adjacency(matrices)
degree(net)

#(iii) Reciprocity; 
dg<-graph.formula(1-+2,1-+3,2++3)
plot(dg)
reciprocity(dg)
dyad.census(dg)
2*dyad.census(dg)$mat/ecount(dg)

#(iv) Transitivity; 
kite<-graph.famous("Krackhardt_Kite")
atri<-adjacent.triangles(kite)
plot(kite, vertex.label=atri)
transitivity(kite, type="local")
adjacent.triangles(kite) / (degree(kite) * (degree(kite)-1)/2)

#(v) Centralization; 
## Degree of centrality
centralization.degree(net, mode="in", normalized=T)
## Closeness Centralization
closeness(net, mode="all", weights=NA)
centralization.closeness(net, mode="all",normalized=T)
## Between Centrality
betweenness(net, directed=T, weights=NA)
edge.betweenness(net, directed=T, weights=NA)
centralization.betweenness(net, directed=T, normalized=T)
## Eigen vector centrality
centralization.evcent(net, directed=T, normalized=T)


#(vi) Clustering.
plot(kite)
get.adjedgelist(kite, mode = c("all", "out", "in", "total"))





#Practical 4: Aim: For a given network find the following:
# (i) Length of the shortest path from a given node to another node.
library(igraph)
matt <- as.matrix(read.table(text= "
node R S T U
R 7 5 0 0
S 7 0 0 2
T 0 6 0 0
U 4 0 1 0", header=T))
nms <- matt[,1 ]
matt <- matt[, -1]
colnames(matt) <- rownames(matt) <- nms
matt[is.na(matt)] <- 0
g <- graph.adjacency(matt, weighted=TRUE)
plot(g)

## Shortest Path
s.paths <- shortest.paths(g, algorithm = "dijkstra")
print(s.paths)
shortest.paths(g, v="R", to="S")
plot(g, edge.label=E(g)$weight)

# (ii) The density of the graph
## The density of a graph is the ratio of the number of edges and the number of possible edges.
library(igraph)
dg <- graph.formula(1-+2, 1-+3, 2++3)
plot(dg)
## Considering Loops
graph.density(dg, loops=TRUE)
## With out considering loops
graph.density(simplify(dg), loops=FALSE)

# (iii) Draw egocentric network of node R with chosen configuration parameters.
# install.packages('ergm.ego')
ego_net <- make_ego_graph(g, order=1, nodes="R")[[1]]
# Plot the egocentric network for node R with custom parameters
plot(ego_net, edge.label=E(ego_net)$weight)







#P5 Write a program to distinguish between a network as a matrix, a network as an edge list, and a network as a sociogram (or “network graph”) using 3 distinct networksrepresentatives of each.

library(igraph)
ng<-graph.formula(Andy++Garth,Garth-+Bill,Bill-+Elena,Elena++Frank,Carol-+Andy,Carol-+Elena,Carol++Dan,Carol++Bill,Dan++Andy,Dan++Bill)
plot(ng)
#A network as a matrix
get.adjacency(ng)
#A network as an edge list
E(ng)
get.adjedgelist(ng,mode="in")




#P6 Write a program to exhibit Structural Equivalence distances, automorphic equivalence, and regular equivalence from a network.
library(sna)
library(igraph)
links2 <- read.csv("Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
eq <- equiv.clust(links2)
plot(eq)

#Get Structural Equivalence distances
g.se<-sedist(links2)
Plot a metric MDS of vertex positions in two dimensions
plot(cmdscale(as.dist(g.se)))

#Blockmodeling
b<-blockmodel(links2,eq,h=10)
plot(b)






#P7 Perform SVD analysis of a network.
library(igraph)
a <- matrix(c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1), 9, 4)
print(a)
svd(a)






#P8 Displaying Bipartite network in the graph format

library(igraph)
davis <-read.csv("davis.csv")
g <- graph.data.frame(davis, directed=FALSE)
plot(g) 

bipartite.mapping(g)
V(g)$type <- bipartite_mapping(g)$type
plot(g)

plot(g, vertex.label.cex = 0.8, vertex.label.color ="black")
V(g)$color <- ifelse(V(g)$type, "lightblue", "salmon")
V(g)$shape <- ifelse(V(g)$type, "circle", "square")
E(g)$color <- "lightgray"
plot(g, vertex.label.cex = 0.8, vertex.label.color ="black")

V(g)$label.color <- "black"
V(g)$label.cex <- 1
V(g)$frame.color <- "gray"
V(g)$size <- 18
plot(g, layout = layout_with_graphopt)
plot(g, layout=layout.bipartite, vertex.size=7,
vertex.label.cex=0.6) 








#P9: Hamming distance.
#install.packages("e1071")
library(e1071)

# Define the binary vectors
x <- c(0, 0, 0, 0)
y <- c(0, 0, 1, 0)
z <- c(0, 1, 1, 1)
w <- c(0, 1, 1, 1)

# Calculate Hamming distances
hamming.distance(x, y)  # Output: 1
hamming.distance(y, z)  # Output: 2
hamming.distance(z, w)  # Output: 0
hamming.distance(x, w)  # Output: 3
hamming.distance(x, z)  # Output: 3